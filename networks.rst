Надёжная передача данных.

Общие допущения:
1. Умеем определять повреждённый пакет (контрольная сумма, все дела...)
2. Все пакеты прихолят в том же порядке, в каком были отправлены.


1. Повреждённые пакеты. Для решения этой проблемы достаточно для каждого из полученных пакетов отправлять квитанцию. Квитанции отправляются от получателя (R) к отправителю (S) и бывают двух типов -- положительные (пакет получен без искажений, ACK) и отрицательные (повреждённый пакет, NACK). S, приняв NACK, отправдяет пакет ещё раз. Здесь и далее рассматриваемый протокол является протоколом с ожиданием подтверждения, т.е., отправив пакет, S ждёт получения квитанции для этого пакета (ACK/NACK) и ничего не делает.
2. Повреждённые квитанции. S отправляет пакет X; R получает пакет X и отправляет ACK; квитанция по дороге искажается. S может приравнять все искажённые квитанции к отрицательным и переотправить X, но R примет X за следующий пакет, а не за повторную отправку (т.к. перед этим он отправил ACK). Чтобы этого избежать пакеты нумеруют. Поскольку пока что мы передаём по одному пакету, достаточно всего 2-х номеров -- 0 и 1. S приравнивает повреждённую квитанцию к NACK; добавляет к каждому отправляемому пакету текущий номер (0 или 1); получив NACK, переотправляет пакет с текущим номером; получив ACK, тоглит номер и отправляет с ним новый пакет. Благодаря этому R знает, какой пакет ему отправили -- "тот же самый" или "новый". Номера для квитанций не нужны, потому что каждая квитанция отправляется в ответ на пакет и пакеты/квитанции не могут переупорядочиваться.
3. Потерянные пакеты/квитанции. S, отправив пакет, включает таймер. Истечение таймера означает для S, что пакет до R не дошёл. И без разницы что потерялось -- пакет до R или ответная квитанция до S, для таймера всё едино -- по его истечению пакет переотправляется и таймер перезапускается. Отрицательные (они же повреждённые) квитанции так же не влияют на таймер -- S их просто дропает.
