Надёжная передача данных.

Общие допущения:
1. Умеем определять повреждённый пакет (контрольная сумма, все дела...)
2. Все пакеты прихолят в том же порядке, в каком были отправлены.


1. Повреждённые пакеты. Для решения этой проблемы достаточно для каждого из полученных пакетов отправлять квитанцию. Квитанции отправляются от получателя (R) к отправителю (S) и бывают двух типов -- положительные (пакет получен без искажений, ACK) и отрицательные (повреждённый пакет, NACK). S, приняв NACK, отправдяет пакет ещё раз. Здесь и далее рассматриваемый протокол является протоколом с ожиданием подтверждения, т.е., отправив пакет, S ждёт получения квитанции для этого пакета (ACK/NACK) и ничего не делает.
2. Повреждённые квитанции. S отправляет пакет X; R получает пакет X и отправляет ACK; квитанция по дороге искажается. S может приравнять все искажённые квитанции к отрицательным и переотправить X, но R примет X за следующий пакет, а не за повторную отправку (т.к. перед этим он отправил ACK). Чтобы этого избежать пакеты нумеруют. Поскольку пока что мы передаём по одному пакету, достаточно всего 2-х номеров -- 0 и 1. S приравнивает повреждённую квитанцию к NACK; добавляет к каждому отправляемому пакету текущий номер (0 или 1); получив NACK, переотправляет пакет с текущим номером; получив ACK, тоглит номер и отправляет с ним новый пакет. Благодаря этому R знает, какой пакет ему отправили -- "тот же самый" или "новый". Номера для квитанций не нужны, потому что каждая квитанция отправляется в ответ на пакет и пакеты/квитанции не могут переупорядочиваться.
3. Потерянные пакеты/квитанции. S, отправив пакет, включает таймер. Истечение таймера означает для S, что пакет до R не дошёл. И без разницы что потерялось -- пакет до R или ответная квитанция до S, для таймера всё едино -- по его истечению пакет переотправляется и таймер перезапускается. Отрицательные (они же повреждённые) квитанции так же не влияют на таймер -- S их просто дропает.

GBN
S отправляет пакеты в пределах окна. R принимает пакеты, до тех пор пока они идут по порядку или до первого повреждённого; после этого R прекращает приём и ждёт следующего по порядку пакета, в ответ на остальные отправляет ACK с номером последнего, полученного по порядку пакета. Таким образом, ACK_N гарантирует получение всех пакетов от 1 до N. Поэтому S, получив ACK_N сдвигает окно вправо до левой границы N+1 (либо не сдвигает, если левая граница уже больше N+1).

SR
Отправитель работает как несколько подотправителей (по кол-ву доступных для отправки пакетов). У каждого подотправителя свой таймер, все подотправители работают параллельно. Если таймер подотправителя истекает без получения подтверждения, пересылается только его пакет. Окно отправителя сдвигается вправо, когда есть подтверждённые пакеты у левой границы окна. У получателя также есть окно. Получатель принимает пакеты, не зависимо, идут они по порядку или нет. Окно получателя сдвигается вправо, когда есть полученные пакеты с отправленным подтверждением у левой границы окна. Если, например, отправитель послал N пакетов, получатель принял их все, отправил подверждения и сдвинул своё окно на N. Но до отправителя дошли все подтверждения, кроме самого левого, то отправитель переотправит этот пакет. Поэтому получатель должен быть готов получить пакет левее его окна (максимум на N пакетов) и отправить ACK, иначе окно отправителя не сдвинется вправо.
